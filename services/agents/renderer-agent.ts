import { BaseAgent, AgentInput, AgentOutput } from "./base-agent";
import { AGENT_CONFIG } from "./agent-config";

export class RendererAgent extends BaseAgent {
    constructor() {
        super("Renderer", AGENT_CONFIG.rendererSystemPrompt);
    }

    async execute(input: AgentInput): Promise<AgentOutput> {
        console.log("Renderer Agent generating Three.js code");

        try {
            // Step 1: Prepare the prompt with the architectural design
            const prompt = this.preparePrompt(input.design, input.requirements);

            // Step 2: Call the LLM to generate Three.js code
            const code = await this.callLLM(prompt, 0.1); // Lower temperature for code generation

            // Step 3: Post-process and validate the code
            const enhancedCode = this.enhanceCode(code, input.design);

            return {
                design: input.design,
                code: enhancedCode,
            };
        } catch (error) {
            console.error("Renderer Agent error:", error);
            return {
                error: `Renderer Agent failed: ${
                    error instanceof Error ? error.message : String(error)
                }`,
                design: input.design,
                code: this.generateFallbackCode(input.design),
            };
        }
    }

    private preparePrompt(design: any, requirements: any): string {
        return `Generate clean, well-structured Three.js code to render the following 3D architectural model:

MODEL DATA:
${JSON.stringify(design, null, 2)}

ORIGINAL REQUIREMENTS:
${JSON.stringify(requirements, null, 2)}

Your code should:
1. Initialize a Three.js scene, camera, and renderer
2. Create each room with transparent walls and solid floors
3. Add doors and windows in the correct positions
4. Include orbit controls for navigation
5. Add appropriate lighting
6. Handle window resizing
7. Use different colors for different room types
8. Add room labels

The code should be complete, runnable, and well-commented.
DO NOT include any HTML, just the JavaScript code for Three.js.`;
    }

    private enhanceCode(code: string, design: any): string {
        // Basic validation - ensure the code mentions key Three.js components
        const hasThreeImport = code.includes("THREE") || code.includes("three");
        const hasScene = code.includes("Scene");
        const hasCamera = code.includes("Camera");
        const hasRenderer = code.includes("Renderer");

        if (!hasThreeImport || !hasScene || !hasCamera || !hasRenderer) {
            console.warn(
                "Generated code missing essential Three.js components"
            );
            return this.generateFallbackCode(design);
        }

        // Add additional comments to enhance readability
        const enhancedCode = `// Three.js code for rendering architectural model
// Generated by RealVision AI platform
${code}`;

        return enhancedCode;
    }

    private generateFallbackCode(design: any): string {
        // Fallback code generation if the LLM fails
        return `// Fallback Three.js code for rendering architectural model
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

// Initialize scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f0f0);

// Initialize camera
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(10, 10, 10);

// Initialize renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Add controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0, 0);
controls.update();

// Add lights
const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
directionalLight.position.set(10, 10, 10);
directionalLight.castShadow = true;
scene.add(directionalLight);

// Create rooms
function createRoom(name, width, length, height, x, y, z) {
  const geometry = new THREE.BoxGeometry(width, height, length);
  const edges = new THREE.EdgesGeometry(geometry);
  const material = new THREE.LineBasicMaterial({ color: 0x000000 });
  const wireframe = new THREE.LineSegments(edges, material);
  wireframe.position.set(x + width/2, y + height/2, z + length/2);
  scene.add(wireframe);

  // Add floor
  const floorGeometry = new THREE.PlaneGeometry(width, length);
  const floorMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xcccccc, 
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.7
  });
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = Math.PI / 2;
  floor.position.set(x + width/2, 0.01, z + length/2);
  floor.receiveShadow = true;
  scene.add(floor);

  return { wireframe, floor };
}

// Create all rooms from the model
${(design.rooms || [])
    .map((room: any) => {
        return `createRoom("${room.name}", ${room.width}, ${room.length}, ${room.height}, ${room.x}, ${room.y}, ${room.z});`;
    })
    .join("\n")}

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

animate();

// Handle window resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});`;
    }
}
